# 如何整合其他项目



本项目的核心应该是`MessageLoop`类。为什么这么说呢， 有了消息循环和任务调度系统之后， 很多事情可以更加合理的安排， 原本写起来很尴尬或者不知如何安排的事情，有了消息循环和任务调度之后就可以变得更加可控，同样也推荐大家通过消息循环和任务的形式，尽可能的让资源的访问正交化，减少不必要的冲突。

项目中没有将协程完全作为一等任务来调度，而是作为辅助性的工具， 半自动化的调度方式来控制。有明确的唤起和切换的语义。 



- 整合其他异步网络服务，例如GRPC client服务. 只要我们将我们调用grpc服务的任务变成协程任务就能非常方便的做到。

  1. 将需要调用grpc服务的父任务以协程方式运行
  2. 将当前协程的resumer保存到grpc异步调用的上下文中
  3. 调用grpc服务并通过`Yield`放弃当前协程
  4. 在grpc响应回来（无论成功或者失败）后通过grpc调用上下文中的resumer恢复挂起的协程
  5. 处理grpc响应

  

  同样的方式可以整合绝大部分异步网络服务。从而让很多有异步能力的网络借助协程使得代码逻辑紧凑清晰， 因为在c++中，因为没有垃圾回收机制，内存依靠自己管理的情况下。各种逻辑分散在各个回调当中， 各种异常处理很容易就导致内存问题，也为问题排查调试带来了非常大的麻烦

- 为什么不Hook系统调用？

  这个问题思考过很久，如果Hook系统调用， 也就意味着所有的task都需要在coro环境中运行;而且会混杂着非hook系统调用与hook过的系统调用。而最根本的问题在于, 完全这样做了之后，集成第三方库，特别是一些较大型的程序的时候，问题的排查变的异常艰难。所以最终还是决定使用线程消息循环作为人物调度的一等公民，让coroutine调度器成为一个半自动化的辅助工具来完成这件事情。

  

- 同步网络类似于MySQL client该如何处理？

  mysql的并发慢在了mysql本身。除了分库分表，读写分离等提升mysql本身处理能力的手段。

  通常服务中大部分都是读取查询服务，我们可以通过多级缓存来解决，我们应该关注的情况是如何改善因为一些写入操作导致其他查询变慢的问题。如果是依赖mysql 写入的服务，且需要等待写入结果的这种。mysql的写入能力有限，如果我们仅仅是依靠开N多个线程的方式来解决这种问题，那么天花板很明显， 系统线程切换成本非常大，上限也有限。

  how to?

  因为瓶颈本身是在mysql。而不是在服务本身，解决的根本之道在于让mysql服务本身有更好的写入能力。而作为程序一端。我们可以通过合理的安排使得写入服务对服务整体的延迟与并发量尽可能的没有影响，也就是说因为写入的慢，我们可以让写入操作的单个请求慢， 但是不能让所有请求都非常高的延迟或者并发能力下降。参考上面grpc客户端整合的例子，下面是借助于MessageLoop和Coroutine调度器的解决办法。

  0. 确保发起mysql请求的人物运行在coro环境中

  1. mysql使用MariaDB的异步客户端
  2. 初始化Mysql对象，通过EventLoop的EventDump注册连接的socket fd
  3. 在每个Mysql connection中管理一个查询的队列，因为mysql本身不支持完全异步的请求。在一个链接上的请求完成之前，不可以在同一个tcp链接上发起新的链接请求的。这个限制就算是Hook也没有办法改变的。如果程序对mysql大量的并发请求读写，只能证明程序规划存在问题。
  4. 通过Task的形式发起异步mysql请求，挂起当前coro。
  5. 当对应mysql链接响应可读时， 读取对应的响应数据，唤起因这个查询挂起的coro
  6. 发起队列中下一个请求（如果存在的话）

  reference: [mariadb async api ref](https://mariadb.com/kb/en/library/using-the-non-blocking-library/)





